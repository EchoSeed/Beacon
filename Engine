import React, { useState, useEffect, useRef, useCallback } from 'react';

// ===== GLYPH CLASS =====
class Glyph {
  constructor(id, tags, ancestry, generation) {
    this.id = id;
    this.tags = tags;
    this.ancestry = ancestry;
    this.generation = generation;
    this.entropyHistory = [];
    this.thermodynamicState = null;
    this.x = Math.random() * 800;
    this.y = Math.random() * 600;
    this.vx = (Math.random() - 0.5) * 2;
    this.vy = (Math.random() - 0.5) * 2;
    this.coordinationEvents = [];
    this.lastCollisionGen = 0;
  }

  get entropy() {
    return this.entropyHistory[this.entropyHistory.length - 1] || 0;
  }

  updateThermodynamics(generation) {
    const history = this.entropyHistory;
    if (history.length < 2) return;

    const H = history[history.length - 1];
    const window = Math.min(10, history.length);
    const dH_dt = (history[history.length - 1] - history[history.length - window]) / window;

    let tau_coherence = 1.0;
    if (history.length > 5) {
      const changes = [];
      for (let i = 1; i < Math.min(20, history.length); i++) {
        if (history.length - i - 1 >= 0) {
          changes.push(history[history.length - i] - history[history.length - i - 1]);
        }
      }
      if (changes.length > 0) {
        const std = Math.sqrt(changes.reduce((a, b) => a + b * b, 0) / changes.length);
        tau_coherence = 1.0 / (std + 0.000001);
      }
    }

    let phi_phase = 0.5;
    if (history.length > 10) {
      const recent = history.slice(-10);
      const min = Math.min(...recent);
      const max = Math.max(...recent);
      if (max > min) {
        phi_phase = (recent[recent.length - 1] - min) / (max - min);
      }
    }

    this.thermodynamicState = { H, dH_dt, tau_coherence, phi_phase, generation };
  }

  resonanceWith(other) {
    if (!this.thermodynamicState || !other.thermodynamicState) return 0;

    const s1 = this.thermodynamicState;
    const s2 = other.thermodynamicState;

    const H_diff = Math.abs(s1.H - s2.H);
    const entropy_compat = 1.0 / (1 + H_diff / 100);

    const rate_product = s1.dH_dt * s2.dH_dt;
    const rate_compat = rate_product < 0 ? Math.min(1.0, Math.abs(rate_product) / 10) : 0.2;

    const phase_diff = Math.abs(s1.phi_phase - s2.phi_phase);
    const phase_compat = Math.cos(phase_diff * Math.PI);

    const tau_ratio = Math.min(s1.tau_coherence, s2.tau_coherence) /
                      Math.max(s1.tau_coherence, s2.tau_coherence);

    return (
      entropy_compat * 0.35 +
      rate_compat * 0.30 +
      phase_compat * 0.20 +
      tau_ratio * 0.15
    );
  }

  update(width, height) {
    this.x += this.vx;
    this.y += this.vy;

    if (this.x < 0 || this.x > width) this.vx *= -1;
    if (this.y < 0 || this.y > height) this.vy *= -1;

    this.x = Math.max(0, Math.min(width, this.x));
    this.y = Math.max(0, Math.min(height, this.y));
  }
}

// ===== ENGINE CLASS =====
class GlyphEngineCore {
  constructor() {
    this.glyphs = new Map();
    this.nextId = 0;
    this.generation = 0;
    this.resonanceMatrix = new Map();
    this.openPipes = new Map();
    this.collisionLog = [];
    this.eventLog = [];
    this.tags = ['origin', 'flex', 'ghost', 'fractal', 'wild', 'mirror', 'unknown', 'stable', 'beacon', 'phase', 'resonant'];
    this.RESONANCE_THRESHOLD = 0.45;
    this.BEACON_UPDATE_INTERVAL = 5;
    this.MAX_GLYPHS = 200;
    this.canvasW = 1200;
    this.canvasH = 600;
  }

  log(msg, type = 'info') {
    this.eventLog.unshift({ msg, type, gen: this.generation, ts: Date.now() });
    if (this.eventLog.length > 30) this.eventLog.length = 30;
  }

  genId() { return `g${String(this.nextId++).padStart(4, '0')}`; }
  randomTag() { return this.tags[Math.floor(Math.random() * this.tags.length)]; }

  calcEntropy(glyph) {
    return glyph.tags.length * 42 + Math.floor(Math.random() * 58) + this.generation * 10;
  }

  createGlyph(tags = null, ancestry = []) {
    if (!tags) {
      tags = [];
      for (let i = 0; i < Math.floor(Math.random() * 3) + 1; i++) tags.push(this.randomTag());
      tags = [...new Set(tags)];
    }
    const glyph = new Glyph(this.genId(), tags, ancestry, this.generation);
    glyph.entropyHistory.push(this.calcEntropy(glyph));
    return glyph;
  }

  store(glyph) {
    this.glyphs.set(glyph.id, glyph);
    if (this.glyphs.size > this.MAX_GLYPHS) {
      const toRemove = Array.from(this.glyphs.keys()).slice(0, 50);
      toRemove.forEach(id => this.glyphs.delete(id));
    }
  }

  collide(parentA, parentB) {
    const childTags = [...new Set([...parentA.tags, ...parentB.tags])];
    if (parentA.tags.length >= 2 && parentB.tags.length >= 2) {
      const mutant = `${parentA.tags[Math.floor(Math.random() * parentA.tags.length)]}+${parentB.tags[Math.floor(Math.random() * parentB.tags.length)]}`;
      childTags.push(mutant);
    }
    const child = this.createGlyph(childTags, [parentA.id, parentB.id]);
    child.x = (parentA.x + parentB.x) / 2 + (Math.random() - 0.5) * 50;
    child.y = (parentA.y + parentB.y) / 2 + (Math.random() - 0.5) * 50;
    this.store(child);
    return child;
  }

  updateThermodynamics() {
    for (const glyph of this.glyphs.values()) {
      // Push new entropy reading each thermo update
      glyph.entropyHistory.push(this.calcEntropy(glyph));
      if (glyph.entropyHistory.length > 50) glyph.entropyHistory.shift();
      glyph.updateThermodynamics(this.generation);
    }
  }

  updateResonanceField() {
    this.resonanceMatrix.clear();
    const arr = Array.from(this.glyphs.values());

    for (let i = 0; i < arr.length; i++) {
      for (let j = i + 1; j < arr.length; j++) {
        const a = arr[i], b = arr[j];
        if (!a.thermodynamicState || !b.thermodynamicState) continue;
        const score = a.resonanceWith(b);
        if (score > this.RESONANCE_THRESHOLD) {
          this.resonanceMatrix.set(`${a.id},${b.id}`, { a, b, score });
        }
      }
    }

    for (const [key, expiry] of this.openPipes.entries()) {
      if (this.generation > expiry) this.openPipes.delete(key);
    }
  }

  coordinate() {
    const pairs = Array.from(this.resonanceMatrix.values())
      .sort((x, y) => y.score - x.score)
      .slice(0, 5);

    let collisions = 0;

    for (const { a, b, score } of pairs) {
      const key = `${a.id},${b.id}`;
      const rev = `${b.id},${a.id}`;
      if (this.openPipes.has(key) || this.openPipes.has(rev)) continue;
      if (a.id === b.id) continue;
      if (a.ancestry.includes(b.id) || b.ancestry.includes(a.id)) continue;
      if (this.generation - a.lastCollisionGen < 10) continue;
      if (this.generation - b.lastCollisionGen < 10) continue;

      this.openPipes.set(key, this.generation + 5);
      const offspring = this.collide(a, b);

      this.collisionLog.push({
        generation: this.generation, parentA: a.id, parentB: b.id,
        offspring: offspring.id, resonance: score
      });

      a.lastCollisionGen = this.generation;
      b.lastCollisionGen = this.generation;
      collisions++;

      this.log(`${a.id} √ó ${b.id} ‚Üí ${offspring.id} (res: ${score.toFixed(3)})`, 'collision');
    }
    return collisions;
  }

  step() {
    this.generation++;
    const g = this.createGlyph();
    this.store(g);

    if (this.generation % this.BEACON_UPDATE_INTERVAL === 0) {
      this.updateThermodynamics();
      this.updateResonanceField();
      if (this.resonanceMatrix.size > 0) {
        this.log(`Resonance: ${this.resonanceMatrix.size} pairs`, 'resonance');
      }
    }

    this.coordinate();

    for (const glyph of this.glyphs.values()) {
      glyph.update(this.canvasW, this.canvasH);
    }
  }

  getStats() {
    const avgRes = this.collisionLog.length > 0
      ? this.collisionLog.reduce((s, e) => s + e.resonance, 0) / this.collisionLog.length
      : 0;
    return {
      generation: this.generation, glyphs: this.glyphs.size,
      collisions: this.collisionLog.length, avgResonance: avgRes,
      resonantPairs: this.resonanceMatrix.size, openPipes: this.openPipes.size,
    };
  }

  reset() {
    this.glyphs.clear(); this.nextId = 0; this.generation = 0;
    this.resonanceMatrix.clear(); this.openPipes.clear();
    this.collisionLog = []; this.eventLog = [];
    for (let i = 0; i < 10; i++) this.store(this.createGlyph());
    this.log('System initialized', 'info');
  }

  // Serialization for persistent storage
  serialize() {
    const glyphs = [];
    for (const g of this.glyphs.values()) {
      glyphs.push({
        id: g.id, tags: g.tags, ancestry: g.ancestry, generation: g.generation,
        entropyHistory: g.entropyHistory.slice(-20), x: g.x, y: g.y,
        vx: g.vx, vy: g.vy, lastCollisionGen: g.lastCollisionGen,
      });
    }
    return {
      glyphs, nextId: this.nextId, generation: this.generation,
      collisionLog: this.collisionLog.slice(-50), eventLog: this.eventLog.slice(-20),
    };
  }

  deserialize(data) {
    if (!data) return;
    this.nextId = data.nextId || 0;
    this.generation = data.generation || 0;
    this.collisionLog = data.collisionLog || [];
    this.eventLog = data.eventLog || [];
    this.glyphs.clear();
    for (const gd of (data.glyphs || [])) {
      const g = new Glyph(gd.id, gd.tags, gd.ancestry, gd.generation);
      g.entropyHistory = gd.entropyHistory || [];
      g.x = gd.x; g.y = gd.y; g.vx = gd.vx; g.vy = gd.vy;
      g.lastCollisionGen = gd.lastCollisionGen || 0;
      this.glyphs.set(g.id, g);
    }
    // Rebuild thermo state
    this.updateThermodynamics();
    this.updateResonanceField();
    this.log(`Restored gen ${this.generation}`, 'info');
  }
}

// ===== RENDER FUNCTIONS (on-demand canvas draw) =====
function renderField(canvas, engine, container) {
  if (!canvas || !engine || !container) return;
  const dpr = window.devicePixelRatio || 1;
  const w = container.clientWidth;
  const h = container.clientHeight;
  canvas.width = w * dpr;
  canvas.height = h * dpr;
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  const ctx = canvas.getContext('2d');
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.scale(dpr, dpr);

  // Keep engine coordinate space fixed at 1200x600
  // Scale from that to actual canvas size for rendering

  // Background
  ctx.fillStyle = '#0a0a0a';
  ctx.fillRect(0, 0, w, h);

  if (engine.glyphs.size === 0) {
    ctx.fillStyle = '#334'; ctx.font = '12px monospace'; ctx.textAlign = 'center';
    ctx.fillText('No glyphs yet.', w / 2, h / 2);
    return;
  }

  // Scale positions to current canvas size
  const scaleX = w / 1200;
  const scaleY = h / 600;

  // Resonance connections
  for (const { a, b, score } of engine.resonanceMatrix.values()) {
    ctx.strokeStyle = `rgba(0, 170, 255, ${score * 0.5})`;
    ctx.lineWidth = 0.5;
    ctx.beginPath();
    ctx.moveTo(a.x * scaleX, a.y * scaleY);
    ctx.lineTo(b.x * scaleX, b.y * scaleY);
    ctx.stroke();
  }

  // Open pipes
  ctx.strokeStyle = 'rgba(255, 170, 0, 0.8)';
  ctx.lineWidth = 1.5;
  for (const key of engine.openPipes.keys()) {
    const [idA, idB] = key.split(',');
    const a = engine.glyphs.get(idA);
    const b = engine.glyphs.get(idB);
    if (a && b) {
      ctx.beginPath();
      ctx.moveTo(a.x * scaleX, a.y * scaleY);
      ctx.lineTo(b.x * scaleX, b.y * scaleY);
      ctx.stroke();
    }
  }

  // Glyphs
  for (const glyph of engine.glyphs.values()) {
    const gx = glyph.x * scaleX;
    const gy = glyph.y * scaleY;
    const radius = Math.max(2, Math.sqrt(glyph.entropy) / 4);

    // Glow
    const gradient = ctx.createRadialGradient(gx, gy, 0, gx, gy, radius * 2.5);
    gradient.addColorStop(0, 'rgba(0, 255, 0, 0.6)');
    gradient.addColorStop(0.5, 'rgba(0, 255, 0, 0.15)');
    gradient.addColorStop(1, 'rgba(0, 255, 0, 0)');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(gx, gy, radius * 2.5, 0, Math.PI * 2);
    ctx.fill();

    // Core
    ctx.fillStyle = '#00ff00';
    ctx.beginPath();
    ctx.arc(gx, gy, radius, 0, Math.PI * 2);
    ctx.fill();

    // Phase ring
    if (glyph.thermodynamicState) {
      const phase = glyph.thermodynamicState.phi_phase;
      ctx.strokeStyle = `hsl(${phase * 120}, 100%, 50%)`;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(gx, gy, radius + 2.5, 0, Math.PI * 2);
      ctx.stroke();
    }
  }

  // Legend
  ctx.font = '9px monospace'; ctx.textAlign = 'left'; ctx.fillStyle = '#334';
  ctx.fillText(`${engine.glyphs.size} glyphs ¬∑ ${engine.resonanceMatrix.size} resonant pairs ¬∑ ${engine.openPipes.size} pipes`, 6, h - 6);

  // Legend dots
  ctx.textAlign = 'right';
  ctx.fillStyle = '#00aaff'; ctx.fillText('‚Äî resonance', w - 6, h - 20);
  ctx.fillStyle = '#ffaa00'; ctx.fillText('‚Äî open pipe', w - 6, h - 6);
}

function renderEntropy(canvas, engine, container) {
  if (!canvas || !engine || !container) return;
  const dpr = window.devicePixelRatio || 1;
  const w = container.clientWidth;
  const h = container.clientHeight;
  canvas.width = w * dpr;
  canvas.height = h * dpr;
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  const ctx = canvas.getContext('2d');
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.scale(dpr, dpr);

  ctx.fillStyle = '#0a0a0a';
  ctx.fillRect(0, 0, w, h);

  // Collect all entropy values from all glyphs' histories
  const allEntropies = [];
  for (const g of engine.glyphs.values()) {
    for (const e of g.entropyHistory) allEntropies.push(e);
  }

  if (allEntropies.length < 2) {
    ctx.fillStyle = '#334'; ctx.font = '12px monospace'; ctx.textAlign = 'center';
    ctx.fillText('Not enough data yet.', w / 2, h / 2);
    return;
  }

  const pad = { t: 24, b: 28, l: 44, r: 12 };
  const pw = w - pad.l - pad.r;
  const ph = h - pad.t - pad.b;
  const min = Math.min(...allEntropies);
  const max = Math.max(...allEntropies);
  const range = max - min || 1;

  // Grid
  ctx.strokeStyle = '#151520'; ctx.lineWidth = 0.5;
  for (let i = 0; i <= 4; i++) {
    const y = pad.t + (ph / 4) * i;
    ctx.beginPath(); ctx.moveTo(pad.l, y); ctx.lineTo(w - pad.r, y); ctx.stroke();
    ctx.fillStyle = '#334'; ctx.font = '8px monospace'; ctx.textAlign = 'right';
    ctx.fillText(Math.round(max - (range / 4) * i), pad.l - 4, y + 3);
  }

  // Line
  ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 1.5; ctx.beginPath();
  allEntropies.forEach((e, i) => {
    const x = pad.l + (i / (allEntropies.length - 1)) * pw;
    const y = pad.t + ph - ((e - min) / range) * ph;
    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
  });
  ctx.stroke();

  // Fill
  ctx.lineTo(pad.l + pw, pad.t + ph);
  ctx.lineTo(pad.l, pad.t + ph);
  ctx.closePath();
  ctx.fillStyle = 'rgba(0, 255, 0, 0.06)';
  ctx.fill();

  // Title
  ctx.fillStyle = '#556'; ctx.font = '10px monospace'; ctx.textAlign = 'center';
  ctx.fillText('Entropy over time', w / 2, 14);
  ctx.fillStyle = '#334'; ctx.font = '8px monospace';
  ctx.fillText(`${allEntropies.length} readings`, w / 2, h - 4);
}

function renderResonance(canvas, engine, container) {
  if (!canvas || !engine || !container) return;
  const dpr = window.devicePixelRatio || 1;
  const w = container.clientWidth;
  const h = container.clientHeight;
  canvas.width = w * dpr;
  canvas.height = h * dpr;
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  const ctx = canvas.getContext('2d');
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.scale(dpr, dpr);

  ctx.fillStyle = '#0a0a0a';
  ctx.fillRect(0, 0, w, h);

  const log = engine.collisionLog;
  if (log.length < 2) {
    ctx.fillStyle = '#334'; ctx.font = '12px monospace'; ctx.textAlign = 'center';
    ctx.fillText('Not enough collisions yet.', w / 2, h / 2);
    return;
  }

  const pad = { t: 24, b: 28, l: 44, r: 12 };
  const pw = w - pad.l - pad.r;
  const ph = h - pad.t - pad.b;
  const vals = log.map(e => e.resonance);
  const min = Math.min(...vals);
  const max = Math.max(...vals);
  const range = max - min || 1;

  // Grid
  ctx.strokeStyle = '#151520'; ctx.lineWidth = 0.5;
  for (let i = 0; i <= 4; i++) {
    const y = pad.t + (ph / 4) * i;
    ctx.beginPath(); ctx.moveTo(pad.l, y); ctx.lineTo(w - pad.r, y); ctx.stroke();
    ctx.fillStyle = '#334'; ctx.font = '8px monospace'; ctx.textAlign = 'right';
    ctx.fillText((max - (range / 4) * i).toFixed(2), pad.l - 4, y + 3);
  }

  // Threshold line
  const threshY = pad.t + ph - ((engine.RESONANCE_THRESHOLD - min) / range) * ph;
  ctx.strokeStyle = '#ff444488'; ctx.lineWidth = 1; ctx.setLineDash([4, 4]);
  ctx.beginPath(); ctx.moveTo(pad.l, threshY); ctx.lineTo(w - pad.r, threshY); ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = '#ff4444'; ctx.font = '8px monospace'; ctx.textAlign = 'left';
  ctx.fillText('threshold', pad.l + 4, threshY - 4);

  // Dots + line
  ctx.strokeStyle = '#00aaff'; ctx.lineWidth = 1; ctx.beginPath();
  vals.forEach((v, i) => {
    const x = pad.l + (i / (vals.length - 1)) * pw;
    const y = pad.t + ph - ((v - min) / range) * ph;
    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
  });
  ctx.stroke();

  // Dots
  vals.forEach((v, i) => {
    const x = pad.l + (i / (vals.length - 1)) * pw;
    const y = pad.t + ph - ((v - min) / range) * ph;
    ctx.fillStyle = '#00aaff'; ctx.beginPath(); ctx.arc(x, y, 2, 0, Math.PI * 2); ctx.fill();
  });

  ctx.fillStyle = '#556'; ctx.font = '10px monospace'; ctx.textAlign = 'center';
  ctx.fillText('Resonance per collision', w / 2, 14);
  ctx.fillStyle = '#334'; ctx.font = '8px monospace';
  ctx.fillText(`${log.length} collisions`, w / 2, h - 4);
}

// ===== MAIN APP =====
const BeaconGlyphEngine = () => {
  const engineRef = useRef(null);
  const canvasRef = useRef(null);
  const canvasContainerRef = useRef(null);
  const intervalRef = useRef(null);
  const [running, setRunning] = useState(false);
  const [stats, setStats] = useState({ generation: 0, glyphs: 0, collisions: 0, avgResonance: 0, resonantPairs: 0, openPipes: 0 });
  const [view, setView] = useState(null); // null | 'field' | 'entropy' | 'resonance' | 'log' | 'analysis'
  const [logs, setLogs] = useState([]);
  const [initialized, setInitialized] = useState(false);
  const [analysisResult, setAnalysisResult] = useState(null);
  const [analysisLoading, setAnalysisLoading] = useState(false);

  // Init
  useEffect(() => {
    const engine = new GlyphEngineCore();
    engineRef.current = engine;
    (async () => {
      try {
        const r = await window.storage.get('beacon-engine-v5');
        if (r?.value) { engine.deserialize(JSON.parse(r.value)); }
      } catch (e) {}
      if (engine.glyphs.size === 0) engine.reset();
      setStats(engine.getStats());
      setLogs([...engine.eventLog]);
      setInitialized(true);
    })();
    return () => { if (intervalRef.current) clearInterval(intervalRef.current); };
  }, []);

  // Run loop
  useEffect(() => {
    if (!initialized) return;
    if (running) {
      intervalRef.current = setInterval(() => {
        const e = engineRef.current;
        e.step();
        setStats(e.getStats());
        setLogs([...e.eventLog]);
      }, 200);
    } else {
      if (intervalRef.current) clearInterval(intervalRef.current);
    }
    return () => { if (intervalRef.current) clearInterval(intervalRef.current); };
  }, [running, initialized]);

  // Auto-save
  useEffect(() => {
    if (!initialized) return;
    const si = setInterval(async () => {
      try { await window.storage.set('beacon-engine-v5', JSON.stringify(engineRef.current.serialize())); } catch (e) {}
    }, 30000);
    return () => clearInterval(si);
  }, [initialized]);

  // Render dispatchers
  const doRender = useCallback((type) => {
    setView(type);
    requestAnimationFrame(() => {
      const canvas = canvasRef.current;
      const container = canvasContainerRef.current;
      const engine = engineRef.current;
      if (!canvas || !engine || !container) return;
      if (type === 'field') renderField(canvas, engine, container);
      else if (type === 'entropy') renderEntropy(canvas, engine, container);
      else if (type === 'resonance') renderResonance(canvas, engine, container);
    });
  }, []);

  const doSave = async () => {
    try {
      await window.storage.set('beacon-engine-v5', JSON.stringify(engineRef.current.serialize()));
      engineRef.current.log('Saved', 'info');
      setLogs([...engineRef.current.eventLog]);
    } catch (e) {}
  };

  const doReset = async () => {
    if (intervalRef.current) clearInterval(intervalRef.current);
    setRunning(false);
    try { await window.storage.delete('beacon-engine-v5'); } catch (e) {}
    engineRef.current.reset();
    setStats(engineRef.current.getStats());
    setLogs([...engineRef.current.eventLog]);
    setView(null); setAnalysisResult(null);
  };

  const doAnalyze = async () => {
    setView('analysis'); setAnalysisLoading(true);
    const engine = engineRef.current;
    const summary = Array.from(engine.glyphs.values()).slice(-20).map(g => ({
      id: g.id, tags: g.tags, entropy: g.entropy,
      thermo: g.thermodynamicState ? {
        H: g.thermodynamicState.H, dH_dt: +g.thermodynamicState.dH_dt.toFixed(3),
        tau: +g.thermodynamicState.tau_coherence.toFixed(3), phi: +g.thermodynamicState.phi_phase.toFixed(3),
      } : null,
    }));
    const recentCollisions = engine.collisionLog.slice(-10).map(c => ({
      parents: `${c.parentA}√ó${c.parentB}`, child: c.offspring, resonance: +c.resonance.toFixed(3),
    }));

    try {
      const res = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          model: 'claude-sonnet-4-20250514', max_tokens: 1000,
          system: `You analyze a beacon-coordinated consciousness simulation using thermodynamic resonance (v_p ‚âà dH/dt / C_s). Glyphs collide when resonance exceeds threshold. Analyze: 1) Thermodynamic patterns (entropy flow, coherence, phase alignment) 2) Resonance clustering 3) Emergent coordination patterns. Respond ONLY in JSON: {patterns:[{name,description}], resonance_analysis:{summary,notable_pairs}, emergence:{level,indicators}}. No markdown.`,
          messages: [{ role: 'user', content: `Glyphs:\n${JSON.stringify(summary)}\n\nRecent collisions:\n${JSON.stringify(recentCollisions)}` }],
        }),
      });
      const data = await res.json();
      const text = data.content.map(i => i.type === 'text' ? i.text : '').filter(Boolean).join('\n');
      setAnalysisResult(JSON.parse(text.replace(/```json|```/g, '').trim()));
      engine.log('Claude analysis complete', 'analysis');
    } catch (e) { console.warn(e); setAnalysisResult(null); }
    setAnalysisLoading(false); setLogs([...engine.eventLog]);
  };

  if (!initialized) return (
    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100vh', background: '#0a0a0a', fontFamily: 'monospace', color: '#00ff00' }}>
      Initializing...
    </div>
  );

  return (
    <div style={{ fontFamily: "'Courier New', monospace", background: '#0a0a0a', color: '#00ff00', minHeight: '100vh', display: 'flex', flexDirection: 'column' }}>

      {/* HEADER */}
      <div style={{ padding: '10px 12px', borderBottom: '1px solid #00ff0044' }}>
        <div style={{ fontSize: 13, fontWeight: 'bold', marginBottom: 6, textShadow: '0 0 8px #00ff0066' }}>
          üß† BEACON GLYPH ENGINE v5.0
        </div>

        {/* Stats grid */}
        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: 4 }}>
          {[
            ['GEN', stats.generation],
            ['GLYPHS', stats.glyphs],
            ['COLLISIONS', stats.collisions],
            ['AVG RES', stats.avgResonance.toFixed(3)],
            ['RES PAIRS', stats.resonantPairs],
            ['PIPES', stats.openPipes],
          ].map(([label, val]) => (
            <div key={label} style={{ padding: '4px 6px', background: '#111', border: '1px solid #1a1a1a', borderRadius: 3, textAlign: 'center' }}>
              <div style={{ fontSize: 7, color: '#555', letterSpacing: '0.1em' }}>{label}</div>
              <div style={{ fontSize: 14, fontWeight: 'bold', color: '#00ff00' }}>{val}</div>
            </div>
          ))}
        </div>
      </div>

      {/* CONTROLS */}
      <div style={{ padding: '8px 12px', display: 'flex', flexDirection: 'column', gap: 4 }}>
        {/* Row 1: Start/Stop */}
        <div style={{ display: 'flex', gap: 4 }}>
          <Btn onClick={() => { setRunning(true); engineRef.current.log('Started', 'info'); setLogs([...engineRef.current.eventLog]); }} disabled={running} style={{ flex: 1, opacity: running ? 0.4 : 1 }}>‚ñ∂ START</Btn>
          <Btn onClick={() => { setRunning(false); engineRef.current.log('Paused', 'info'); setLogs([...engineRef.current.eventLog]); }} disabled={!running} style={{ flex: 1, opacity: !running ? 0.4 : 1 }}>‚è∏ PAUSE</Btn>
          <Btn onClick={doSave} style={{ flex: 0.7 }}>üíæ</Btn>
          <Btn onClick={doReset} style={{ flex: 0.7, borderColor: '#333', color: '#555' }}>‚Ü∫</Btn>
        </div>

        {/* Row 2: Render buttons */}
        <div style={{ display: 'flex', gap: 4 }}>
          <Btn onClick={() => doRender('field')} style={{ flex: 1 }}>‚¨° Field</Btn>
          <Btn onClick={() => doRender('entropy')} style={{ flex: 1 }}>üìà Entropy</Btn>
          <Btn onClick={() => doRender('resonance')} style={{ flex: 1 }}>„Ä∞ Resonance</Btn>
        </div>

        {/* Row 3: Analysis + Log */}
        <div style={{ display: 'flex', gap: 4 }}>
          <Btn onClick={doAnalyze} disabled={analysisLoading} style={{ flex: 1, borderColor: '#00aaff', color: '#00aaff' }}>
            {analysisLoading ? '‚è≥ Analyzing...' : 'üß† Claude Analysis'}
          </Btn>
          <Btn onClick={() => setView(view === 'log' ? null : 'log')} style={{ flex: 0.7, borderColor: view === 'log' ? '#00ff00' : '#1a3a1a' }}>‚ñ§ Log</Btn>
        </div>
      </div>

      {/* OUTPUT AREA */}
      {view && (
        <div style={{ flex: 1, position: 'relative', margin: '0 12px 12px', minHeight: 0 }}>
          {/* Close */}
          <button onClick={() => setView(null)} style={{ position: 'absolute', top: 4, right: 6, background: 'none', border: 'none', color: '#334', fontSize: 16, cursor: 'pointer', zIndex: 2, padding: 4 }}>‚úï</button>

          {/* Canvas views */}
          {(view === 'field' || view === 'entropy' || view === 'resonance') && (
            <div ref={canvasContainerRef} style={{ background: '#0a0a0a', border: '1px solid #1a3a1a', borderRadius: 4, overflow: 'hidden', height: 'calc(55vh)', minHeight: 300, width: '100%' }}>
              <canvas ref={canvasRef} style={{ display: 'block' }} />
            </div>
          )}

          {/* Log view */}
          {view === 'log' && (
            <div style={{ background: '#111', border: '1px solid #1a3a1a', borderRadius: 4, padding: 10, maxHeight: 'calc(100vh - 340px)', minHeight: 200, overflow: 'auto' }}>
              {logs.length === 0 && <div style={{ color: '#334', fontSize: 11 }}>No events yet.</div>}
              {logs.map((log, i) => (
                <div key={i} style={{
                  padding: '6px 8px', marginBottom: 4, background: '#0a0a0a',
                  borderLeft: `3px solid ${log.type === 'collision' ? '#ffaa00' : log.type === 'resonance' ? '#00aaff' : log.type === 'analysis' ? '#ff44cc' : '#00ff00'}`,
                  fontSize: 11, lineHeight: 1.4,
                }}>
                  <div style={{ color: '#444', fontSize: 9 }}>Gen {log.gen}</div>
                  <div style={{ color: '#00ff00', wordBreak: 'break-word' }}>{log.msg}</div>
                </div>
              ))}
            </div>
          )}

          {/* Analysis view */}
          {view === 'analysis' && (
            <div style={{ background: '#111', border: '1px solid #1a3a1a', borderRadius: 4, padding: 12, maxHeight: 'calc(100vh - 340px)', minHeight: 200, overflow: 'auto' }}>
              {analysisLoading && <div style={{ color: '#00aaff', fontSize: 11 }}>Running Claude analysis on thermodynamic state...</div>}
              {analysisResult && (
                <div style={{ fontSize: 11, lineHeight: 1.6 }}>
                  {analysisResult.patterns && (
                    <div style={{ marginBottom: 10 }}>
                      <div style={{ fontSize: 9, fontWeight: 'bold', color: '#00aaff', letterSpacing: '0.1em', marginBottom: 4 }}>PATTERNS</div>
                      {analysisResult.patterns.map((p, i) => (
                        <div key={i} style={{ padding: '3px 0', color: '#0c0' }}>
                          <strong style={{ color: '#0f0' }}>{p.name}</strong>: <span style={{ color: '#8a8' }}>{p.description}</span>
                        </div>
                      ))}
                    </div>
                  )}
                  {analysisResult.resonance_analysis && (
                    <div style={{ marginBottom: 10 }}>
                      <div style={{ fontSize: 9, fontWeight: 'bold', color: '#00aaff', letterSpacing: '0.1em', marginBottom: 4 }}>RESONANCE</div>
                      <div style={{ color: '#8a8' }}>{analysisResult.resonance_analysis.summary}</div>
                      {analysisResult.resonance_analysis.notable_pairs && (
                        <div style={{ color: '#ffaa00', marginTop: 4 }}>{JSON.stringify(analysisResult.resonance_analysis.notable_pairs)}</div>
                      )}
                    </div>
                  )}
                  {analysisResult.emergence && (
                    <div>
                      <div style={{ fontSize: 9, fontWeight: 'bold', color: '#00aaff', letterSpacing: '0.1em', marginBottom: 4 }}>EMERGENCE</div>
                      <div style={{ color: '#0f0' }}>Level: <strong>{analysisResult.emergence.level}</strong></div>
                      {analysisResult.emergence.indicators && (
                        <div style={{ color: '#8a8', marginTop: 2 }}>
                          {(Array.isArray(analysisResult.emergence.indicators) ? analysisResult.emergence.indicators : [analysisResult.emergence.indicators]).map((ind, i) => (
                            <div key={i}>‚Üí {typeof ind === 'string' ? ind : JSON.stringify(ind)}</div>
                          ))}
                        </div>
                      )}
                    </div>
                  )}
                </div>
              )}
              {!analysisLoading && !analysisResult && <div style={{ color: '#334', fontSize: 11 }}>No analysis yet.</div>}
            </div>
          )}
        </div>
      )}

      {/* FOOTER STATS */}
      {!view && (
        <div style={{ padding: '8px 12px', fontSize: 9, color: '#1a3a1a', textAlign: 'center', borderTop: '1px solid #111' }}>
          Tap a render button to visualize ¬∑ Engine runs in background
        </div>
      )}
    </div>
  );
};

function Btn({ children, onClick, disabled, style = {} }) {
  return (
    <button onClick={onClick} disabled={disabled} style={{
      padding: '9px 6px', fontSize: 10, fontWeight: 'bold',
      fontFamily: "'Courier New', monospace",
      border: '1px solid #1a3a1a', borderRadius: 3, background: '#111',
      color: '#00ff00', cursor: disabled ? 'not-allowed' : 'pointer',
      letterSpacing: '0.05em', ...style,
    }}>
      {children}
    </button>
  );
}

export default BeaconGlyphEngine;
